Решение и ответ сильно отличаются. В решении используются коррелированные запросы для каждого параметра,
тогда как ответ использует кардинально иной подход с заметно лучшей читаемостью и производительностью. 

В ответе для построения статистики экспедиций используется CTE для формирования отчёта каждой из таблиц. 

Первое выражение expedition_stats формирует статистику экспедиции (id, назначение, статус, всего участников, выжившие участники,
ценность предметов, исследованные места, количество встреч с созданиями время выхода и возвращения). Для получения результирующего выражения
производится сбор информации из таблиц expeditions, expedition_members, expedition_artifacts, expedition_sites, expedition_creatures и 
последующая группировка по id экспедиции, назначению, статусу и датам выхода и возвращения. Стоит обратить внимание на получение 
агрегируемых и вычисляемых параметров:
- total_members - обычная агрегация по количеству гномов (em.dwarf_id).
- survivors - выжившие гномы. Для расчёта используется агрегатная функция SUM внутри которой используется выражение CASE 
  преобразующее булевый параметр. Если параметр равен TRUE, то в выражении будет 1.0, иначе 0.0. Таким образом
  получаем подсчёт только живых гномов.
- artifacts_value - ценность предметов. Для расчёта используется комбинация функций COALESCE и SUM. SUM вычисляет суммарную
  ценность предметов по столбцу ea.value, а COALESCE обрабатывает случай, когда сумма является NULL - отсутствуют предметы.
- discovered_sites - количество исследованных мест. Для расчёта используется агрегатная функция COUNT с выборкой уникальных
  id мест.
- favorable_encounters - количество успешных встреч. По аналогии с survivors тут используется сочетание функции SUM и 
  выражения CASE для суммирования только успешных встреч.
- total_encounters - простая агрегация по количеству встреч (ec.creature_id).

Второе выражение skills_progression предназначено для удобства получения изменения опыта участников экспедиции. Оно объединяет таблицы expedition_members,
dwarves, dwarf_skills и expeditions через INNER JOIN. Причём таблица dwarf_skills используется в качестве 2 копий ds_before и
ds_after. Значение ds_before выбирается сопоставление по id с таблицей dwarves, а значение ds_after выбирается на основе совпадения 
по id между записями таблиц dwarves и совпадению по id скилов между записями ds_before и ds_after. Затем производится фильтрация 
значений по дате - выбираются значения с датой до и после отправки в экспедицию. ВЗатем данные группируются по id экспедиции.
После этого производится расчёт изменения левела для каждого гнома и эти изменения суммируются для группы. При расчёте суммы
также задействуется функция COALESCE для обработки случая, когда параметр level одной из копий таблиц является NULL.

После подготовки выражений выполняется основной запрос в котором используются подготовленные данные. Здесь объединяются 
данные из выражений expedition_stats и skills_progression с помощью LEFT JOIN по ID экспедиции.  Поля expedition_id,
destination, status, surviving_members, total_members, es.artifacts_value, es.discovered_sites используются напрямую из 
первого выражения expedition_stats. 
Отдельно рассмотрим вычисляемые столбцы:
- Для расчёта survival_rate используется приведение типа поля es.survivors к DECIMAL, для уменьшения погрешности расчётов,
  а затем данные округляются до 2 знаков после запятой.
- Для расчёта skill_improvement подстраховываем вычисления с помощью функции COALESCE для случая если sp.total_skill_improvement
  является NULL.
- При расчёте encounter_success_rate используется сочетание методов COALESCE, ROUND, NULLIF и приведения типов для получения 
  нужного значения. NULLIF используется для защиты от деления на 0, функция подменяет es.total_encounters на NULL если он равен 0.
- Для расчёта expedition_duration используется выражение EXTRACT для получения количества дней экспедиции.
- Общий счёт overall_success_score рассчитывается как средневзвешенная значение, где 30% составляют участники, 25% сумма 
  ценности предметов, 15% количество исследованных мест, 15% количество успешных встреч и 15% изменения уровня участников.
- related_entities представляют JSON-объект c набором JSON-массивов для member_ids, artifact_ids и site_ids.

Данные для всех экспедиций предоставляются в отсортированном по overall_success_score виде. Сортировка по убыванию.


Сравнивая решение с ответом заметил, что допустил ошибку при расчёте survival_rate - выводится не в процентах. В моём 
решении отсутствуют проверки деления на 0 и учёт отсутствия некоторых значений, что может приводить к ошибкам при выполнении
запроса. Для overall_success_score пытался найти таблицу на основе которой может быть получен параметр когда всё было в какой-то 
степени проще. Однако, всё же, было бы трудно подобрать такие коэффициенты, которые дали бы значения из возможного решения.
Также решение содержит избыточное дублирование логики в подзапросах, что делает код сложным и медленным. 


Итог:
Моё решение опирается на коррелированные подзапросы, из-за чего код стал громоздким, плохо читаемым и потенциально медленным. 
Эталон использует CTE, которые позволяют сначала агрегировать данные, а затем использовать их более чисто и прозрачно. 
Особенно наглядна разница в расчётах survival rate, encounter success и skill improvement. Я также не предусмотрел обработку 
NULL и деления на ноль, что делает моё решение нестабильным. На будущее желательно сначала агрегировать всё необходимое в CTE,
и только потом проводить вычисления и форматирование. Это делает запрос понятнее, устойчивее и стабильнее.

В этом задании открыл много новых функций и выражений для себя - табличные выражения (CTE с WHEN), CASE, COALESCE, ROUND, NULLIF, 
EXTRACT. Постараюсь уместно использовать их в дальнейшем.  
